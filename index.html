<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> 3D scene </title>

    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
          }
        }
      </script>


    <script type="module">

        import * as THREE from "https://threejs.org/build/three.module.js";
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm'
        import cannonEsDebugger from 'https://cdn.jsdelivr.net/npm/cannon-es-debugger@1.0.0/+esm'
        import { MapControls } from 'three/addons/controls/MapControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        var debugcannon;

        // loader
        const loader = new GLTFLoader();

        // Camera Positions
        const [cameraOffsetX, cameraOffsetY, cameraOffsetZ] = [8, 6, 8]

        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            renderer: null,
            camera: null,
            sceneGraph: null,   // visual world
            world: null,        // physics world
            raycaster: null,
            pointer: null,
        };

        // HELPER FUNCTIONS

        const helper = {

            initEmptyScene: function (sceneElements) {

                // ************************** //
                // Create the 3D scene
                // ************************** //
                sceneElements.sceneGraph = new THREE.Scene();

                // ************************** //
                // Add camera
                // ************************** //
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;
                camera.position.set(cameraOffsetX, cameraOffsetY, cameraOffsetZ);
                camera.lookAt(0, 0, 0);

                // ************************** //
                // Illumination
                // ************************** //

                // ************************** //
                // Add ambient light
                // ************************** //
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)');
                sceneElements.sceneGraph.add(ambientLight);

                // ***************************** //
                // Add spotlight (with shadows)
                // ***************************** //
                const spotLight1 = new THREE.SpotLight('rgb(255, 255, 255)', 40);
                spotLight1.decay = 1;
                spotLight1.position.set(-5, 8, 0);
                sceneElements.sceneGraph.add(spotLight1);

                // Setup shadow properties for the spotlight
                spotLight1.castShadow = true;
                spotLight1.shadow.mapSize.width = 2048;
                spotLight1.shadow.mapSize.height = 2048;
                spotLight1.name = "light 1";

                // *********************************** //
                // Create renderer (with shadow map)
                // *********************************** //
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(255, 255, 150)', 1.0);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // **************************************** //
                // Add the rendered image in the HTML DOM
                // **************************************** //
                const htmlElement = document.querySelector("#Tag3DScene");
                htmlElement.appendChild(renderer.domElement);

                // ************************** //
                // Control for the camera
                // ************************** //
                const controls = new MapControls( camera, renderer.domElement );
                sceneElements.controls = controls
                // how far can you dolly in and out
                // controls.minDistance = 10.0
                // controls.maxDistance = 20.0
                // Disable rotating
                // controls.enableRotate = false; 
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.panSpeed = 2

                // ************************** //
                // Create raycaster and pointer
                // ************************** //
                sceneElements.raycaster = new THREE.Raycaster();
                sceneElements.pointer = new THREE.Vector2();

                // ************************** //
                // Create physics world
                // ************************** //
                sceneElements.world = new CANNON.World({
                    gravity: new CANNON.Vec3(0, -9.82, 0), // m/sÂ²
                })

                debugcannon = new cannonEsDebugger(sceneElements.sceneGraph, sceneElements.world);
            },

            render: function (sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        // FUCNTIONS FOR BUILDING THE SCENE
        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function (sceneGraph) {

                // ************************** //
                // Create a ground plane
                // ************************** //
                const planeGeometry = new THREE.PlaneGeometry(48, 48);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(200, 200, 200)', side: THREE.DoubleSide });
                const planeObject = new THREE.Mesh(planeGeometry, planeMaterial);
                sceneGraph.add(planeObject);
                // Change orientation of the plane using rotation
                planeObject.rotation.x = Math.PI/2
                // Set shadow property
                planeObject.receiveShadow = true;

                // ************************** //
                // Coordinate Axis
                // ************************** //
                const axes = new THREE.AxesHelper(15);
                sceneGraph.add(axes);
                
                // ************************** //
                // Create a cube
                // ************************** //
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,0,0)' });
                const cubeObject = new THREE.Mesh(cubeGeometry, cubeMaterial);
                sceneGraph.add(cubeObject);
                // Cube center is at (0,0,0)
                // Set position of the cube
                // The base of the cube will be on the plane 
                cubeObject.translateY(10);
                // Set shadow property
                cubeObject.castShadow = true;
                cubeObject.receiveShadow = true;
                cubeObject.name = "cube";

                

                // Create a static plane for the ground
                const groundBody = new CANNON.Body({
                    type: CANNON.Body.STATIC, // can also be achieved by setting the mass to 0
                    shape: new CANNON.Plane(), // in z = 0
                })
                groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
                sceneElements.world.addBody(groundBody)

                // ************************** //
                // Create the Car Model
                // ************************** //
                loadBall();
                loadCar();
                console.log("after load ball")

                // ************************** //
                // Create an empty rectangle
                // ************************** //
                const empty_rectangle = new THREE.Group()
                const points = [
                    new THREE.Vector3( -1, 0, 1),
                    new THREE.Vector3( 1, 0, 1),
                    new THREE.Vector3( 1, 0, -1),
                    new THREE.Vector3( -1, 0, -1),
                    new THREE.Vector3( -1, 0, 1,)
                ];
                const material = new THREE.LineBasicMaterial( {
                    color: 0x0000ff ,
                    linewidth: 10,    // Line thickness
                    opacity: 0.5,    // Line opacity
                    transparent: true // Enable transparency
                } );
                const geometry = new THREE.BufferGeometry().setFromPoints( points );
                const line = new THREE.Line( geometry, material );
                empty_rectangle.add(line);
                line.name = "empty_rectangle"
                empty_rectangle.name = "empty_rectangle"
                sceneElements.sceneGraph.add(line)
            }
        };

        // ************************** //
        // ANIMATION
        // Displacement Values
        var dispX = 0.2, dispZ = 0.2;
        // To keep Track of the keyboard
        var carMoved = false;
        var keyArrowLeft = false, keyArrowUp = false, keyArrowRight = false, keyArrowDown = false;
        var keyEnter = false;
        // ************************** //
        function computeFrame(time) {
            const empty_rectangle = sceneElements.sceneGraph.getObjectByName("empty_rectangle");


            sceneElements.raycaster.setFromCamera( sceneElements.pointer, sceneElements.camera);
            // console.log(sceneElements.pointer)
            // console.log(sceneElements.camera)
            const cube = sceneElements.sceneGraph.getObjectByName("cube");

            sceneElements.raycaster.set(cube.position, new THREE.Vector3(0, 1, 0));
            const intersects2 = sceneElements.raycaster.intersectObject( empty_rectangle );
            if (intersects2.length > 0){
                // console.log("cube intersecting empty_rectangle")
                if (keyEnter){
                    // console.log("key enter pressed")
                    // empty_rectangle.children[0].material.color.setHex( 0x0000ff );
                }
            } else {
                // empty_rectangle.children[0].material.color.setHex( 0x000000 );
            }

            
            if (keyArrowRight) {
                cube.translateX(dispX);
                carMoved = true;
            }
            if (keyArrowUp) {
                cube.translateZ(-dispZ);
                carMoved = true;
            }
            if (keyArrowLeft) {
                cube.translateX(-dispX);
                carMoved = true;
            }
            if (keyArrowDown) {
                cube.translateZ(dispZ);
                carMoved = true;
            }
            if (carMoved){
                // If car moved, then track the car.
                const camera = sceneElements.camera;
                const cameraOffset = new THREE.Vector3(cameraOffsetX, cameraOffsetY, cameraOffsetZ);
                const cubePosition = new THREE.Vector3();
                cube.getWorldPosition(cubePosition);
                camera.position.copy(cubePosition).add(cameraOffset);
                sceneElements.controls.target = cubePosition
            }

            debugcannon.update()
            sceneElements.controls.update(); // required if controls.enableDamping is set to true
            // Rendering
            helper.render(sceneElements);
            // Animation
            // Call for the next frame
            requestAnimationFrame(computeFrame);

            // Run the simulation
            sceneElements.world.fixedStep()

            // Link visual and physics world
            // console.log(sceneElements.world.bodies)
            // sphere   
            const sphereMesh = sceneElements.sceneGraph.getObjectByName("ball_1")
            if (sphereMesh != undefined){
                const sphereBody = sceneElements.world.bodies[getPhysicsWorldId("ball_1")]
                sphereMesh.position.copy(sphereBody.position)
                sphereMesh.quaternion.copy(sphereBody.quaternion)
            }
            // vehicle
            const vehicleGroup = sceneElements.sceneGraph.getObjectByName("vehicleGroup_2")
            if (vehicleGroup != undefined){
                const vehicleBody = sceneElements.world.bodies[getPhysicsWorldId("vehicleGroup_2")]
                vehicleGroup.position.copy({x: vehicleBody.position.x, y: vehicleBody.position.y - 0.3, z: vehicleBody.position.z})
                vehicleGroup.quaternion.copy(vehicleBody.quaternion)
            }
        }

        // ************************** //
        // HELPER FUNCTIONS
        // 1. Load, add to the scene and world the ball model at the position (0,0,0)
        // 2. Load, add to the scene and world the Car Model at the position (0, 0, 0) facing the z axis
        // 3. visual_world_name = custom_name + physicsWorldId. Function to get the physicsWorldId from visual_world_name
        // ************************** //
        function loadBall() {
            const sphereBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Sphere(0.68),
            })
            sphereBody.position.set(0,10,0)
            sceneElements.world.addBody(sphereBody)
            const scaleFactor = 0.7
            loader.load( "rocket_league_ball.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor,scaleFactor,scaleFactor)
                gltf.scene.name = "ball_1"
                sceneElements.sceneGraph.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `loadBall() - Error loading model rocket_league_ball.glb:\n${error}`);
            } );
            
        }

        function loadCar() {
            const backX = -0.40; // same for both wheels at the back
            const backZ =  0.30; // symetric for both wheels at the back
            const frontX = 0.45; // same for both wheels at the front
            const frontZ = 0.27; // symetric for both wheels at the front
            const scaleFactor = 0.01
            const vehicleGroup = new THREE.Group();
            vehicleGroup.name = "vehicleGroup_2"

            // physics vehichle
            const vehicleBody = new CANNON.Body({
                mass: 10,
                shape: new CANNON.Box(new CANNON.Vec3(0.71, 0.28, 0.4))
            })
            const raycastVehicle = new CANNON.RaycastVehicle({
                chassisBody: vehicleBody
            })
            
            // back left
            loader.load( "rocket_league_octane_wheel_bl.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor, scaleFactor, scaleFactor);
                gltf.scene.translateX(backX)
                gltf.scene.translateZ(-backZ)
                gltf.scene.name = "lbw_2"
                sceneElements.sceneGraph.add(gltf.scene)
                vehicleGroup.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `Back Left Wheel - Error loading model rocket_league_octane_wheel_bl.glb:\n${error}`);
            } );
            /* raycastVehicle.addWheel({
                radius: 1,
                height: 1,
                suspensionStiffness: 1,
                suspensionRestLength: 2,
                frictionSlip: 2,
                dampingRelaxation: 3,
                dampingCompression: 5,
                maxSuspensionForce: 4,
                rollInfluence: 3,
                maxSuspensionTravel: 3,
                customSlidingRotationalSpeed: 3,
                useCustomSlidingRotationalSpeed: true,
                directionLocal: new CANNON.Vec3(0, 0, - 1),
                axleLocal: new CANNON.Vec3(0, 1, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0)
            }) */
            

            // back right
            loader.load( "rocket_league_octane_wheel_bl.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor, scaleFactor, scaleFactor);
                gltf.scene.translateX(backX)
                gltf.scene.translateZ(backZ)
                gltf.scene.rotateY(Math.PI)
                gltf.scene.name = "rbw_2"
                sceneElements.sceneGraph.add(gltf.scene)
                vehicleGroup.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `Back Right Wheel - Error loading model rocket_league_octane_wheel_bl.glb:\n${error}`);
            } );

            // front left
            loader.load( "rocket_league_octane_wheel_fl.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor, scaleFactor, scaleFactor);
                gltf.scene.translateX(frontX)
                gltf.scene.translateZ(-frontZ)
                gltf.scene.name = "lfw_2"
                sceneElements.sceneGraph.add(gltf.scene)
                vehicleGroup.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `Front Left Wheel - Error loading model rocket_league_octane_wheel_fl.glb:\n${error}`);
            } );

            // front right
            loader.load( "rocket_league_octane_wheel_fl.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor, scaleFactor, scaleFactor);
                gltf.scene.translateX(frontX)
                gltf.scene.translateZ(frontZ)
                gltf.scene.rotateY(Math.PI)
                gltf.scene.name = "lfw_2"
                sceneElements.sceneGraph.add(gltf.scene)
                vehicleGroup.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `Front Right Wheel - Error loading model rocket_league_octane_wheel_fl.glb:\n${error}`);
            } );

            // chassi
            loader.load( "rocket_league_octane_chassi.glb", function ( gltf ) {
                gltf.scene.scale.set(scaleFactor, scaleFactor, scaleFactor);
                gltf.scene.name = "chassi_2"
                sceneElements.sceneGraph.add(gltf.scene)
                vehicleGroup.add(gltf.scene)
            }, undefined, function ( error ) {
                console.error( `Error loading model chassi: ${error}`);
            } );

            raycastVehicle.addToWorld(sceneElements.world)
            sceneElements.sceneGraph.add(vehicleGroup)
            
        }

        function getPhysicsWorldId(visual_world_name) {
            return parseInt(visual_world_name.split("_").pop())
        }

        // ************************** //
        // HANDLING EVENTS
        //   1. Resize Window
        //   2. User interaction with keyboard
        //   3. User interaction with mouse
        // ************************** //
        window.addEventListener('resize', resizeWindow);
        // Update render image (size) and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();

            sceneElements.renderer.setSize(width, height);

            // Comment when doing animation
            // computeFrame(sceneElements);
        }

        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        function onDocumentKeyDown(event) {
            console.log(event.keyCode)
            switch (event.keyCode) {
                case 13: // Enter
                    keyEnter = true;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = true;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = true;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = true;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = true;
                    break;
            }
        }

        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 13: // Enter
                    keyEnter = false;
                    break;
                case 37: // ArrowLeft
                    keyArrowLeft = false;
                    carMoved = false;
                    break;
                case 38: // ArrowUp
                    keyArrowUp = false;
                    carMoved = false;
                    break;
                case 39: // ArrowRight
                    keyArrowRight = false;
                    carMoved = false;
                    break;
                case 40: // ArrowDown
                    keyArrowDown = false;
                    carMoved = false;
                    break;
            }
        }

        document.addEventListener( 'pointermove', onPointerMove );
        function onPointerMove( event ) {
            sceneElements.pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            sceneElements.pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            // console.log(sceneElements.pointer)
        }

        // ************************** //
        // INITIALIZATION
        //  1. Initialize the empty scene
        //  2. Add elements within the scene
        //  3. Animate
        // ************************** //
        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(computeFrame);
        }

        // STARTING
        init();

    </script>

</head>

<body>
    <div id="Tag3DScene"> </div>
</body>

</html>